import { SuiClient } from '@mysten/sui/client';
import { Ed25519Keypair } from '@mysten/sui/keypairs/ed25519';
import { Transaction } from '@mysten/sui/transactions';
import {
  genAddressSeed,
  generateNonce,
  generateRandomness,
  getZkLoginSignature,
  jwtToAddress,
} from '@mysten/sui/zklogin';

import { zkLoginConfig } from './config';
import type { PartialZkLoginSignature, ZkLoginState } from './types';
import { decodeJwt, generateUserSalt } from './utils';

// Define the result type for transaction execution
interface TransactionResult {
  digest: string;
  effects?: unknown;
  events?: unknown[];
  objectChanges?: unknown[];
  balanceChanges?: unknown[];
}

export class ZkLoginService {
  private suiClient: SuiClient;
  private state: ZkLoginState | null = null;

  constructor(rpcUrl: string) {
    this.suiClient = new SuiClient({ url: rpcUrl });
  }

  /**
   * Initialize zkLogin session by generating ephemeral keypair and nonce
   */
  async initializeSession(): Promise<{ nonce: string; loginUrl: string }> {
    // Get current epoch information
    const { epoch } = await this.suiClient.getLatestSuiSystemState();

    // Set maxEpoch (ephemeral key will be active for 2 epochs from now)
    const maxEpoch = Number(epoch) + 2;

    // Generate ephemeral keypair and randomness
    const ephemeralKeyPair = new Ed25519Keypair();
    const randomness = generateRandomness();
    const nonce = generateNonce(ephemeralKeyPair.getPublicKey(), maxEpoch, randomness);

    // Store state
    this.state = {
      ephemeralKeyPair,
      randomness,
      nonce,
      maxEpoch,
    };

    // Store in session storage for persistence
    this.saveStateToStorage();

    return {
      nonce,
      loginUrl: '', // Login URL will be generated by the calling code using generateLoginUrl utility
    };
  }

  /**
   * Process JWT token and generate zkLogin address
   */
  processJwtToken(jwtToken: string, userSalt?: string): string {
    if (!this.state) {
      throw new Error('zkLogin session not initialized. Call initializeSession() first or ensure session was restored from storage.');
    }

    // Validate that we have the minimum required state for processing JWT
    if (!this.state.ephemeralKeyPair || !this.state.randomness || !this.state.nonce) {
      throw new Error('zkLogin session is incomplete. Missing ephemeral keypair, randomness, or nonce.');
    }

    // Decode and validate JWT
    const decodedJwt = decodeJwt(jwtToken);

    // Generate or use provided user salt
    const salt = userSalt ?? generateUserSalt();

    // Generate zkLogin Sui address
    const zkLoginAddress = jwtToAddress(jwtToken, salt);

    // Update state
    this.state = {
      ...this.state,
      jwtToken,
      decodedJwt,
      userSalt: salt,
      zkLoginAddress,
    };

    // Save updated state
    this.saveStateToStorage();

    console.debug('JWT processed successfully', {
      address: zkLoginAddress,
      hasUserSalt: !!salt,
      jwtValid: !!decodedJwt,
    });

    return zkLoginAddress;
  }

  /**
   * Get zero-knowledge proof from the prover service
   */
  async getZkProof(): Promise<PartialZkLoginSignature> {
    if (!this.state?.jwtToken || !this.state.userSalt) {
      throw new Error('JWT token not processed. Call processJwtToken() first.');
    }

    const { jwtToken, userSalt, maxEpoch, randomness, ephemeralKeyPair } = this.state;

    // Prepare proof request payload
    const zkpRequestPayload = {
      jwt: jwtToken,
      extendedEphemeralPublicKey: ephemeralKeyPair.getPublicKey().toBase64(),
      maxEpoch: String(maxEpoch),
      jwtRandomness: randomness,
      salt: userSalt,
      keyClaimName: 'sub',
    };

    try {
      // Call the prover service
      const response = await fetch(zkLoginConfig.proverUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(zkpRequestPayload),
      });

      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`Prover service error: ${String(response.status)} ${errorText}`);
      }

      const zkProof = await response.json() as PartialZkLoginSignature;

      // Store proof in state
      this.state.zkProof = zkProof;
      this.saveStateToStorage();

      return zkProof;
    } catch (error) {
      throw new Error(`Failed to get ZK proof: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Sign and execute a transaction using zkLogin
   */
  async executeTransaction(transaction: Transaction): Promise<TransactionResult> {
    if (!this.state?.zkLoginAddress || !this.state.zkProof || !this.state.decodedJwt || !this.state.userSalt) {
      throw new Error('zkLogin not fully initialized. Complete the login flow first.');
    }

    const { ephemeralKeyPair, zkProof, decodedJwt, userSalt, maxEpoch, zkLoginAddress } = this.state;

    // Set transaction sender
    transaction.setSender(zkLoginAddress);

    // Sign transaction with ephemeral key
    const { bytes, signature: userSignature } = await transaction.sign({
      client: this.suiClient,
      signer: ephemeralKeyPair,
    });

    // Generate address seed - these fields are guaranteed to exist after validation
    const subValue = decodedJwt.sub;
    const audValue = decodedJwt.aud;

    if (!subValue || !audValue) {
      throw new Error('JWT missing required sub or aud fields');
    }

    // Ensure aud is a string (it can be string | string[])
    const audString = Array.isArray(audValue) ? audValue[0] : audValue;

    if (!audString) {
      throw new Error('JWT aud field is empty');
    }

    const addressSeed = genAddressSeed(
      BigInt(userSalt),
      'sub',
      subValue,
      audString,
    ).toString();

    // Create zkLogin signature
    const zkLoginSignature = getZkLoginSignature({
      inputs: {
        ...zkProof,
        addressSeed,
      },
      maxEpoch,
      userSignature,
    });

    // Execute transaction
    return await this.suiClient.executeTransactionBlock({
      transactionBlock: bytes,
      signature: zkLoginSignature,
    }) as TransactionResult;
  }

  /**
   * Get current zkLogin address
   */
  getAddress(): string | null {
    return this.state?.zkLoginAddress ?? null;
  }

  /**
   * Get current session state
   */
  getState(): ZkLoginState | null {
    return this.state;
  }

  /**
   * Clear current session
   */
  clearSession(): void {
    this.state = null;
    if (typeof window !== 'undefined') {
      sessionStorage.removeItem('zklogin_state');
    }
  }

  /**
   * Restore session from storage
   */
  restoreSession(): boolean {
    if (typeof window === 'undefined') {
      console.debug('zkLogin: Server-side environment, skipping session restoration');
      return false;
    }

    try {
      const stored = sessionStorage.getItem('zklogin_state');
      if (!stored) {
        console.debug('zkLogin: No session found in storage (this is normal for first-time users)');
        return false;
      }

      console.debug('zkLogin: Found session data in storage, attempting to restore...', {
        dataLength: stored.length,
        dataPreview: `${stored.substring(0, 200)  }...`
      });

      const parsedState = JSON.parse(stored) as {
        ephemeralKeyPair?: { secretKey: number[] };
        randomness?: string;
        nonce?: string;
        maxEpoch?: number;
        jwtToken?: string;
        decodedJwt?: unknown;
        userSalt?: string;
        zkLoginAddress?: string;
        zkProof?: unknown;
        [key: string]: unknown;
      };

      console.debug('zkLogin: Session data structure check:', {
        hasEphemeralKeyPair: !!parsedState.ephemeralKeyPair?.secretKey,
        hasRandomness: !!parsedState.randomness,
        hasNonce: !!parsedState.nonce,
        hasMaxEpoch: typeof parsedState.maxEpoch === 'number',
        hasJwtToken: !!parsedState.jwtToken,
        hasAddress: !!parsedState.zkLoginAddress,
        maxEpoch: parsedState.maxEpoch,
        ephemeralKeyPairType: typeof parsedState.ephemeralKeyPair,
        secretKeyLength: parsedState.ephemeralKeyPair?.secretKey?.length,
      });

      // Validate that we have the essential data for session restoration
      if (!parsedState.ephemeralKeyPair?.secretKey ||
          !parsedState.randomness ||
          !parsedState.nonce ||
          typeof parsedState.maxEpoch !== 'number') {
        console.warn('zkLogin: Invalid or incomplete session data in storage:', {
          missingEphemeralKeyPair: !parsedState.ephemeralKeyPair?.secretKey,
          missingRandomness: !parsedState.randomness,
          missingNonce: !parsedState.nonce,
          missingMaxEpoch: typeof parsedState.maxEpoch !== 'number',
          ephemeralKeyPair: parsedState.ephemeralKeyPair,
        });
        // Clear invalid session data
        sessionStorage.removeItem('zklogin_state');
        return false;
      }

      // Restore ephemeral keypair
      try {
        console.debug('zkLogin: Attempting to restore ephemeral keypair from secretKey array:', {
          secretKeyArray: `${parsedState.ephemeralKeyPair.secretKey.slice(0, 5)  }...`, // Log first 5 elements for debug
          secretKeyLength: parsedState.ephemeralKeyPair.secretKey.length,
        });

        const keypair = Ed25519Keypair.fromSecretKey(
          new Uint8Array(parsedState.ephemeralKeyPair.secretKey)
        );

        console.debug('zkLogin: Ephemeral keypair restored successfully');

        this.state = {
          ephemeralKeyPair: keypair,
          randomness: parsedState.randomness,
          nonce: parsedState.nonce,
          maxEpoch: parsedState.maxEpoch,
          jwtToken: parsedState.jwtToken,
          decodedJwt: parsedState.decodedJwt,
          userSalt: parsedState.userSalt,
          zkLoginAddress: parsedState.zkLoginAddress,
          zkProof: parsedState.zkProof,
        } as ZkLoginState;

        console.info('zkLogin: Session restored successfully', {
          hasJwtToken: !!this.state.jwtToken,
          hasAddress: !!this.state.zkLoginAddress,
          maxEpoch: this.state.maxEpoch,
          isComplete: !!(this.state.jwtToken && this.state.zkLoginAddress),
        });

        return true;
      } catch (keypairError) {
        console.error('zkLogin: Failed to restore ephemeral keypair:', keypairError);
        console.error('zkLogin: SecretKey data that caused the error:', {
          secretKey: parsedState.ephemeralKeyPair.secretKey,
          secretKeyType: typeof parsedState.ephemeralKeyPair.secretKey,
          isArray: Array.isArray(parsedState.ephemeralKeyPair.secretKey),
        });
        sessionStorage.removeItem('zklogin_state');
        return false;
      }
    } catch (error) {
      console.warn('zkLogin: Failed to restore session from storage:', error);
      console.warn('zkLogin: Raw session data that caused parsing error:', stored.substring(0, 200));
      // Clear potentially corrupted session data
      sessionStorage.removeItem('zklogin_state');
      return false;
    }
  }

  /**
   * Force session restoration - useful for callback scenarios
   * Returns detailed information about the restoration attempt
   */
  forceRestoreSession(): { success: boolean; error?: string; hasData: boolean } {
    if (typeof window === 'undefined') {
      return { success: false, error: 'Server-side environment', hasData: false };
    }

    const stored = sessionStorage.getItem('zklogin_state');
    if (!stored) {
      return { success: false, error: 'No session data found', hasData: false };
    }

    try {
      const restored = this.restoreSession();
      return {
        success: restored,
        error: restored ? undefined : 'Session restoration failed',
        hasData: true,
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
        hasData: true,
      };
    }
  }

  /**
   * Save current state to session storage
   */
  private saveStateToStorage(): void {
    if (typeof window === 'undefined' || !this.state) return;

    try {
      // Serialize state with ephemeral keypair
      const stateToSave = {
        ...this.state,
        ephemeralKeyPair: {
          publicKey: this.state.ephemeralKeyPair.getPublicKey().toBase64(),
          secretKey: Array.from(this.state.ephemeralKeyPair.getSecretKey()),
        },
      };

      sessionStorage.setItem('zklogin_state', JSON.stringify(stateToSave));
    } catch (error) {
      console.warn('Failed to save zkLogin state to storage:', error);
    }
  }

  /**
   * Check if current session is valid (ephemeral key not expired)
   */
  async isSessionValid(): Promise<boolean> {
    if (!this.state?.maxEpoch) return false;

    try {
      const { epoch } = await this.suiClient.getLatestSuiSystemState();
      return Number(epoch) <= this.state.maxEpoch;
    } catch {
      return false;
    }
  }

  /**
   * Debug utility: Inspect current session storage state
   */
  static debugSessionStorage(): void {
    if (typeof window === 'undefined') {
      console.debug('zkLogin Debug: Server-side environment, no sessionStorage');
      return;
    }

    const stored = sessionStorage.getItem('zklogin_state');

    if (!stored) {
      console.debug('zkLogin Debug: No session data found in sessionStorage');
      return;
    }

    try {
      const parsed = JSON.parse(stored) as {
        ephemeralKeyPair?: { secretKey: number[] };
        randomness?: string;
        nonce?: string;
        maxEpoch?: number;
        jwtToken?: string;
        zkLoginAddress?: string;
        userSalt?: string;
        zkProof?: unknown;
        [key: string]: unknown;
      };

      console.debug('zkLogin Debug: Session storage contents:', {
        hasData: !!stored,
        dataLength: stored.length,
        hasEphemeralKeyPair: !!parsed.ephemeralKeyPair?.secretKey,
        hasRandomness: !!parsed.randomness,
        hasNonce: !!parsed.nonce,
        hasMaxEpoch: typeof parsed.maxEpoch === 'number',
        hasJwtToken: !!parsed.jwtToken,
        hasAddress: !!parsed.zkLoginAddress,
        hasUserSalt: !!parsed.userSalt,
        hasZkProof: !!parsed.zkProof,
        maxEpoch: parsed.maxEpoch,
        address: parsed.zkLoginAddress,
        // Don't log sensitive data like keys or tokens
      });
    } catch (error) {
      console.error('zkLogin Debug: Failed to parse session storage data:', error);
      console.debug('zkLogin Debug: Raw storage data:', `${stored.substring(0, 100)}...`);
    }
  }
}
